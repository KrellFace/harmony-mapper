from mido import Message
from Midi import *

note_letters = ["a", "a#", "b", "c", "c#", "d", "d#", "e", "f", "f#", "g", "g#"]
major_scale_positions = [0, 2, 4, 5, 7, 9, 11]
minor_scale_positions = [0, 2, 3, 5, 7, 8, 10]


#A key signature contains 7 notes, and is defined by its start note and whether its major or minor
#The key signature is generated by looping through the scale positions, but starting from the initial note
#i.e a Key signature in minor key starting with note 'c' which is at index 3 will then add the 5th note letter 'd', followed by the 7th 'e', all the way to 'b', at the index 3 


class KeySignature:

    def __init__(self, note_letter, major_or_minor):
        self.note_letter = note_letter
        self.major_or_minor = major_or_minor
        if self.major_or_minor == "maj":
            self.scale_positions = major_scale_positions
        if self.major_or_minor == "min":
            self.scale_positions = minor_scale_positions
        self.scale_letters = []
        start_ind = note_letters.index(self.note_letter)
        for pos in self.scale_positions:
            ind = (start_ind + pos) % 12
            self.scale_letters.append(note_letters[ind])

    def __str__(self):
        return self.note_letter + self.major_or_minor

    #Takes in an input chord, and returns true if all notes in the chord are in the key signature 
    def is_in_key(self, chord):
        chord_letters = chord.get_note_letters()
        for letter in chord_letters:
            if letter not in self.scale_letters:
                return False
        return True

    #Either ascend or descend through the notes in the key signature to find the next one in the given direction
    def next_note_in_direction(self, current_note, target_note):
        if current_note == target_note:
            return None
        addon = 1 if target_note > current_note else -1
        note = current_note
        is_ok = False
        while note != target_note and is_ok is False:
            note += addon
            #No idea why we have to add 3 to the note index here though 
            letter = note_letters[(note + 3) % 12]
            if letter in self.scale_letters:
                is_ok = True
        return note




class Trichord:

    #Every chord has 3 notes, a duration
    #Not sure what being an 'event' chord means though 
    def __init__(self, notes):
        self.notes = notes
        self.duration_ticks = 0
        self.is_event_chord = False
        self.timestamp_ms = 0

    def __str__(self):
        #        return f"{self.notes[0]},{self.notes[1]},{self.notes[2]}"
        s = ""
        for letter in self.get_note_letters():
            s += f"{letter},"
        addon = ""
        if self.is_major():
            addon = "(maj)"
        elif self.is_minor():
            addon = "(min)"
        return s[:-1] + addon

    #Generates a key signature based on the first note of the chord
    #Theres that wierd +3 again though
    def get_key_signature(self):
        a, b, c = self.mapped_to_majmin_base()
        letter = note_letters[(a + 3) % 12]
        majmin = "maj" if self.is_major() else "min"
        return KeySignature(letter, majmin)

    
    #Loops through 3 different versions of the chord, after they have been mapped to mid octave
    #Breaks out of the loop return true to is major, if any verison of these 3 chords has the 2nd note 4 positions above the 1st, and the 3rd note 3 positions above the 2nd
    #I guess the 3 diff versions are to account for different positions the chord could be in and that making the math hard 
    def is_major(self):
        a, b, c = self.mapped_to_mid_octave()
        for t1, t2, t3 in [[a, b, c], [c - 12, a, b], [b - 12, c - 12, a]]:
            if t2 - t1 == 4 and t3 - t2 == 3:
                return True
        return False

    def is_minor(self):
        a, b, c = self.mapped_to_mid_octave()
        for t1, t2, t3 in [[a, b, c], [c - 12, a, b], [b - 12, c - 12, a]]:
            if t2 - t1 == 3 and t3 - t2 == 4:
                return True
        return False

    #I guess this is handling for shifting the notes such that a < b < c
    def mapped_to_majmin_base(self):
        a, b, c = self.mapped_to_mid_octave()
        mapped_notes = []
        for t1, t2, t3 in [[a, b, c], [c - 12, a, b], [b - 12, c - 12, a]]:
            #Presumably handling for minor key
            if t2 - t1 == 3 and t3 - t2 == 4:
                mapped_notes = [t1, t2, t3]
                break
            #Major key?
            if t2 - t1 == 4 and t3 - t2 == 3:
                mapped_notes = [t1, t2, t3]
                break
        return mapped_notes

    def get_note_letters(self):
        letters = []
        for note in self.notes:
            letters.append(note_letters[(note + 3) % 12])
        return letters

    #Apply individual NRO shift to every note in this chord, then return the new chord 
    def apply_nro(self, nro):
        notes = []
        for ind, operator in enumerate(nro.operators):
            notes.append(self.notes[ind] + operator)
        output_trichord = Trichord(notes)
        return output_trichord
    
    #Some clunkiness here - not sure why we need to repeatedly call 'mapped_to_majmin_base()'
    #I guess we need to reapply it, because after each NRO shift we may have shifted over the boundary where no loner a<b<c
    def apply_compound_nro(self, compound_nro, map_to_majmin=False):
        output_trichord = Trichord(self.notes)
        #print("Applying to compound NRO: " + str(compound_nro))
        if map_to_majmin:
            output_trichord.notes = output_trichord.mapped_to_majmin_base()
        for nro in compound_nro.nros:
            output_trichord = output_trichord.apply_nro(nro)
            if map_to_majmin:
                output_trichord.notes = output_trichord.mapped_to_majmin_base()
        return output_trichord

    #Checks if a chord is valid, where valid means no notes the same, no notes only a semi tone apart, no notes more than an octave apart 
    def is_admissable(self):
        a, b, c = self.notes

        # Must be a trichord with three distinct note categories
        l1, l2, l3 = self.get_note_letters()
        if l1 == l2 or l1 == l3 or l2 == l3:
            return False

        # Must not have two notes apart by only a semitone
        ind1 = note_letters.index(l1)
        ind2 = note_letters.index(l2)
        ind3 = note_letters.index(l3)
        if abs(ind1 - ind2) <= 1 or abs(ind1 - ind3) <= 1 or abs(ind2 - ind3) <= 1:
            return False

        #Notes also cannot be an entire octave apart 
        if abs(ind1 - ind2) >= 12 or abs(ind1 - ind3) >= 12 or abs(ind2 - ind3) >= 12:
            return False

        return True

    def map_to_focal_note(self, focal_note):
        #This line is redundant 
        #min_dist = 1000000
        mapped_chord = []

        #Loop through the 3 notes
        #For each, find the same note in a different octave that is as close to the focal note as possible 
        for note in self.notes:
            min_dist = 10000
            try_note = note + (12 * 5)
            mapped_note = note
            while try_note > 0:
                dist = abs(focal_note - try_note)
                if dist < min_dist:
                    mapped_note = try_note
                    min_dist = dist
                try_note -= 12
            mapped_chord.append(mapped_note)
        mapped_chord.sort()
        self.notes = mapped_chord

    #Same as map to focal note, expect mapped to the octave between 60 and 72 
    def mapped_to_mid_octave(self):
        mapped_chord = []
        for note in self.notes:
            try_note = note + (12 * 5)
            mapped_note = note
            while try_note > 0:
                if try_note >= 60 and try_note < 72:
                    mapped_note = try_note
                try_note -= 12
            mapped_chord.append(mapped_note)
        mapped_chord.sort()
        return mapped_chord

    #Start and end primary prop just seem to relate to volume

    #Also worth noting, it appears to be directly updating the tracks held in the MidiTracks object
    #Which i guess is a singleton?
    def add_to_tracks(self, volume, start_primary_prop, end_primary_prop):

        #print("Add to tracks in Chords.py called")

        #So this loops through the 3 notes
        for track_num, note in enumerate(self.notes):
            #First it retrieves the primary and secondary track for the note (I guess each of the 3 notes has its own track)
            primary_track = MidiTracks.primary_chord_tracks[track_num]
            secondary_track = MidiTracks.secondary_chord_tracks[track_num]

            #This rhythm appears to never be used?
            #It doesnt throw an error, but I expected and tested that 
            num_rnotes = len(self.rhythm.rhythm_notes)

            #Checking the number of these mysterious rhythm notes (always seems to be 1)
            #print(f"RhythmLength: {num_rnotes}")

            #Not sure what all this is doing
            #The end primary volume vars are only used ir num_rnotes is not 1, which never seems to be the case 
            start_primary_volume = volume * start_primary_prop
            start_secondary_volume = volume * (1 - start_primary_prop)
            end_primary_volume = volume * end_primary_prop
            end_secondary_volume = volume * (1 - end_primary_prop)

            primary_volume_addon = 0 if num_rnotes == 1 else (end_primary_volume - start_primary_volume)/(num_rnotes - 1)
            secondary_volume_addon = 0 if num_rnotes == 1 else (end_secondary_volume - start_secondary_volume)/(num_rnotes - 1)

            #Loop may be currently redundant if there are only ever 1 rhythm notes             
            for ind, rnote in enumerate(self.rhythm.rhythm_notes):
                primary_volume = int(round(start_primary_volume + (primary_volume_addon * ind)))
                secondary_volume = int(round(start_secondary_volume + (secondary_volume_addon * ind)))
                #Not sure what the double message adds are about, one with time = 0, one with a start tick 
                #But basically just adds messages to turn the notes on or off for the primary and secondary channels 

                #I guess they are just activated, but never turned on as velocity/volume = 0
                if ind == 0 and rnote.start_tick > 0:
                    primary_track.append(Message(type='note_on', channel=MidiChannels.primary_chord_channel, note=note, velocity=0, time=0))
                    primary_track.append(Message(type='note_on', channel=MidiChannels.primary_chord_channel, note=note, velocity=0, time=rnote.start_tick))
                    secondary_track.append(Message(type='note_on', channel=MidiChannels.secondary_chord_channel, note=note, velocity=0, time=0))
                    secondary_track.append(Message(type='note_on', channel=MidiChannels.secondary_chord_channel, note=note, velocity=0, time=rnote.start_tick))
                primary_track.append(Message(type='note_on', channel=MidiChannels.primary_chord_channel, note=note, velocity=primary_volume, time=0))
                primary_track.append(Message(type='note_off', channel=MidiChannels.primary_chord_channel, note=note, velocity=primary_volume, time=rnote.cutoff_tick))
                secondary_track.append(Message(type='note_on', channel=MidiChannels.secondary_chord_channel, note=note, velocity=secondary_volume, time=0))
                secondary_track.append(Message(type='note_off', channel=MidiChannels.secondary_chord_channel, note=note, velocity=secondary_volume, time=rnote.cutoff_tick))
                pad_ticks = rnote.duration_ticks - rnote.cutoff_tick
                if pad_ticks > 0:
                    primary_track.append(Message(type='note_on', channel=MidiChannels.primary_chord_channel, note=60, velocity=0, time=0))
                    primary_track.append(Message(type='note_off', channel=MidiChannels.primary_chord_channel, note=60, velocity=0, time=pad_ticks))
                    secondary_track.append(Message(type='note_on', channel=MidiChannels.secondary_chord_channel, note=60, velocity=0, time=0))
                    secondary_track.append(Message(type='note_off', channel=MidiChannels.secondary_chord_channel, note=60, velocity=0, time=pad_ticks))
